# Task2

Здесь все достаточно просто, для реализации стэка будем использовать односвязный список, с которым мы уже знакомы !

# Task3

1. Когда в стэке нечетное количество элементов:
    на n - 1 вызове pop() - будет ошибка о том, что стэк пуст -> цикл прервется и программа завершится с ошибкой
2. Когда в стэке четное (не равное 0) количество элементов:
    поскольку мы каждую итерацию цикла удаляем по 2 элемента, то цикл отработает корректно и завершится без ошибок
-> в конце размер стэка будет равен 0
3. Когда в стэке количество элементов равно 0:
    цикл не будет выполнен, так как количество элементов равно 0

# Task4 and Task5

Суть данного задания заключается в том, чтобы проверить: правильно ли составлена последовательность из скобок? 
Для этого мы используем стэк и последовательность из скобок, если набор скобок верный, то они должны "схлопнуть" друг друга и на выходе будет пустой стэк. Для этого мы определим определенный алгоритм, в котором будем использовать свойство символа, конкретнее о том, что символ представляет из себя байт в памяти и его можно представить в виде строки, а между нашими символами (скобками) есть определенная разница, которую мы и будем находить для того, чтобы понимать: схлопнет данная эта скобка другую?
Дан набор символов: () [] {}
Из набора понятно, что зеркально стоящая скобка схлопывает другую скобку.

Алгоритм следующий:
1. Проходимся циклом по набору входящих скобок
2. Если стэк пуст - добавляем скобку
3. Если в стэке есть хотя бы один элемент - достаем верхушку стэка
4. Находим разницу между текущей скобкой и верхушкой стэка
5. Если разница равна 1 или 2, тогда удаляем из стэка верхушку
6. В противном случае - добавляем скобку в стэк
7. В конце проверяем стэк на пустоту
8. Если стэк пуст - набор скобок корректен
9. В противном случае  - некорректен

# Task6 and Task7

Для реализации данной функции мы добавим в нашу реализацию стэка поле - min, которое содержит в себе динамический массив из последних минимумов - последний элемент в массиве - текущий минимум. То есть для каждого элемента в стэке мы определяем текущий для этого элемента минимум, тем самым гарантируя нахождение всех минимумов в стэке.

Алгоритм при заполнении стэка (push):
1. Проверяем стэк на пустоту
2. Если пуст - кладем первый минимум в min
3. В противном случае сравниваем текущий минимум с элементом, который хотим поместить в стэк, если первый оказался меньше - кладем новый минимум в min
4. В противном случае - кладем старый минимум в min

Со средним значением куда проще, просто добавляем поле sum - в котором будет хранится сумма всех элементов в стэке, когда хотим найти среднее, то прото возращаем:
$`\frac{stack.sum}{stack.size}`$

# Task8

Для решения данного задания, в принципе, алгоритм был уже описан в уроке. То есть мы берем элементы из одного стэка, определяем является ли он числом или строкой. Если является числом, то кладем его в другой стэк, если строка, тогда определяем, какой именно символ нам дается, в зависимости от символа (оператора), мы вычисляем значение. Для этого мы достаем из стэка с числами два операнда и совмещаем их с текущим операндом, а результат помещаем стэк с числами. В итоге в стэке с числами у нас остается результат выражения.

Для данной задачи использовал метод приведения интерфейных типов, так как стэк - динамически типизирован. Для этого в ```go``` есть удобная конструкция ```switch type```  